{"version":3,"sources":["webpack://InquiryMonad/webpack/universalModuleDefinition","webpack://InquiryMonad/webpack/bootstrap","webpack://InquiryMonad/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","simple_maybe_1","noop","$$inquirySymbol","Symbol","$$questionsetSymbol","$$notFoundSymbol","$$questionSymbol","IOU","concat","head","Array","isArray","length","tail","isEmpty","Boolean","[object Object]","isPass","isFail","isIOU","Pass","fold","answer","Inquiry","informant","subject","fail","iou","pass","questionset","Fail","Question","a","extract","exportQuestion","console","error","questionTypeError","Questionset","find","RegExp","test","b","warn","exportQuestionset","questionsetTypeError","InquirySubject","inquire","fExtractFn","fIsFn","fnName","inquireResponse","resp","warnNotPassFail","inquireMap","reduce","inq","ii","using","swap","unison","breakpoint","milestone","conclude","cleared","faulted","suffice","scratch","zip","exportInquiry","warnTypeError","InquiryPSubject","InquiryP","InquiryPOf","warnTypeErrorP","buildInq","vals","acc","cur","then","response","syncronousResult","__awaiter","this","Promise","all","catch","err","await","t","Infinity","timeLimit","resolve","reject","setTimeout","awaitPromises","race","exportInquiryP"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,kBAAAH,GACA,iBAAAC,QACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA2CA,OAtCAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACAkB,OAAAC,eAAAnB,EAAA,cAAiDwB,OAAA,KAIjDlB,EAAAmB,EAAA,SAAAxB,GACA,IAAAe,EAAAf,KAAAyB,WACA,WAA2B,OAAAzB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDtB,EAAAyB,EAAA,GAIAzB,IAAA0B,EAAA,mBCnEA,MAAAC,EAAAC,KACAC,QAAA,EACAC,WAAA,EACAC,QAAAC,WAA0BJ,KAC1BK,IAAAC,GAAAC,EAAAC,GAAAF,EAAAN,IACAS,GAAAC,KAAAL,IAAAL,GACAW,MAAAL,KAAAN,GACAY,KAAAR,GAAAJ,EACAa,KAAA,CAAAT,EAAAU,MAAAd,GACAe,SAAAP,GAAAR,EAAAK,IAAAE,EAAAC,MAGAQ,EAAAZ,KACAH,QAAA,EACAC,WAAA,EACAC,QAAAC,GAAA,UACAC,IAAAD,GAAAY,IACAP,GAAAL,GAAAY,IACAL,MAAAP,GAAAY,IACAJ,KAAAR,GAAAY,IACAH,KAAA,CAAAP,EAAAF,IAAAE,IACAS,SAAAP,KAAAQ,OAGAT,GACAC,GAAAR,GAAA,OAAAA,QAAAiB,IAAAjB,EAAAgB,IAAAjB,EAAAC,IAGAjC,EAAAD,SAAkByC,QAAAS,UAAAjB,sXC5BlB,MAAAmB,EAAA9C,EAAA,GAaM+C,EAAO,OAEPC,EAAiCC,SA8qBnCvD,EAAAsD,kBA7qBJ,MAAME,EAAqCD,SA8qBvCvD,EAAAwD,sBA7qBJ,MAAMC,EAAkCF,SAClCG,EAAkCH,SAElCI,EAAUzB,KACZK,IAAMC,GAAgBmB,EAAInB,EAAEN,IAC5BW,MAAQL,GAAgBA,EAAEN,GAC1BS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBG,QAAS,WAAqBH,KAC9BY,KAAM,IAAMZ,EACZ0B,OAAS3C,GACLA,EAAE4B,MAAOtB,GAAWoC,EAAKzB,EAAe0B,OAAOrC,KACnDsC,KAAM,IAAOC,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAE,MAC9C+B,KAAM,IAAOH,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAEA,EAAE8B,OAAS,MACzDE,QAAS,IAAMC,SAASL,MAAMC,QAAQ7B,IAAmB,IAAbA,EAAE8B,QAE9CI,CAACd,IAAkB,EACnBe,QAAQ,EACRC,QAAQ,EACRC,OAAO,IAypBPvE,EAAA2D,MAtpBJ,MAAMa,EAAWtC,KACbK,IAAMC,GAAgBgC,EAAKhC,EAAEN,IAC7BW,MAAQL,GAAgBA,EAAEN,GAC1BuC,KAAM,CAACjC,EAAaF,IAAgBE,EAAEN,GACtCa,KAAM,CAACT,EAAaE,IAAgBA,EAAEN,GACtC2B,KAAM,IAAOC,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAE,MAC9C+B,KAAM,IAAOH,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAEA,EAAE8B,OAAS,MACzDlB,KAAM,IAAMZ,EACZG,QAAS,YAAsBH,KAC/B0B,OAAS3C,GACLA,EAAEwD,KAAMlD,GAAWiD,EAAMtC,EAAe0B,OAAOrC,IAAK,MACxDoB,GAAKC,GAAsBA,EAAEyB,OAASzB,EAAEgB,OAAOY,EAAKtC,IAAMsC,EAAKtC,GAC/DwC,OAAQ,CACJlE,EACAiB,EAAY,cACZZ,EAAc8D,KAEdnE,EAAEoE,WAAWnD,EAAG+C,EAAKtC,KACdrB,GACHgE,QAASrE,EAAEqE,QACXC,KAAMtE,EAAEsE,KACRC,IAAKvE,EAAEuE,IACPC,KAAMxE,EAAEwE,KAAKpB,OAAOY,EAAKtC,IACzB0C,UAAWpE,EAAEoE,UACbK,YAAazE,EAAEyE,eAGvBf,QAAS,IAAMC,SAASL,MAAMC,QAAQ7B,IAAmB,IAAbA,EAAE8B,QAC9CK,QAAQ,EACRC,QAAQ,EACRC,OAAO,EAEPH,CAACd,IAAkB,IAqnBnBtD,EAAAwE,OAlnBJ,MAAMU,EAAWhD,KACbK,IAAMC,GAAgB0C,EAAK1C,EAAEN,IAC7BW,MAAQL,GAAgBA,EAAEN,GAC1BuC,KAAM,CAACnC,EAAaE,IAAgBA,EAAEN,GACtCa,KAAM,CAACP,EAAaF,IAAgBE,EAAEN,GACtC2B,KAAM,IAAOC,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAE,MAC9C+B,KAAM,IAAOH,MAAMC,QAAQ7B,IAAMA,EAAE8B,OAAS9B,EAAEA,EAAE8B,OAAS,MACzDlB,KAAM,IAAMZ,EACZG,QAAS,YAAsBH,KAC/B0B,OAAS3C,GACLA,EAAE8B,KAAMxB,GAAW2D,EAAMhD,EAAe0B,OAAOrC,IAAK,MACxDoB,GAAKC,GAAsBA,EAAEyB,OAASa,EAAKhD,GAAKU,EAAEgB,OAAOsB,EAAKhD,IAC9DwC,OAAQ,CACJlE,EACAiB,EAAY,cACZZ,EAAc8D,KAEdnE,EAAEoE,WAAWnD,EAAGyD,EAAKhD,KACdrB,GACHgE,QAASrE,EAAEqE,QACXC,KAAMtE,EAAEsE,KAAKlB,OAAOsB,EAAKhD,IACzB8C,KAAMxE,EAAEwE,KACRD,IAAKvE,EAAEuE,IACPH,UAAWpE,EAAEoE,UACbK,YAAazE,EAAEyE,eAGvBf,QAAS,IAAMC,SAASL,MAAMC,QAAQ7B,IAAmB,IAAbA,EAAE8B,QAC9CK,QAAQ,EACRC,QAAQ,EACRC,OAAO,EAEPH,CAACd,IAAkB,IAilBnBtD,EAAAkF,OA9kBJ,MAMMC,EAAYjD,KACdK,IAAMC,GAAgB2C,EAAS3C,EAAEN,IACjCW,MAAQL,GAAgBA,EAAEN,GAC1BS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBG,QAAS,gBAA0BH,KACnCY,KAAM,IAAMZ,EACZvB,KAAOyE,GAAqBlD,EAAE,GAAgBkD,EAAEtC,OAAO+B,QAAQ/B,QAC/DuC,QAAS,IAAMnD,EAAE,GAEjBkC,CAACV,IAAmB,IAMlB4B,GACF5C,GAJgBR,GAChB4B,MAAMC,QAAQ7B,GAAKiD,EAASjD,GAnBN,CAACA,GACvBqD,QAAQC,MACJ,gGACAtD,GAgB6BuD,CAAkBvD,IA0jBjClC,EAAAmF,SAAAG,EApjBtB,MAAMI,EACFxD,KAEAK,IAAMC,GAAgBkD,EAAYlD,EAAEN,IACpCW,MAAQL,GAAgBA,EAAEN,GAC1BS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBG,QAAS,mBAA6BH,KACtCY,KAAM,IAAMZ,EACZyD,KAAOP,GACHhC,EAAAX,MAAMC,GAAGR,EAAEyD,KAAKnF,GAAKoF,OAAOpF,EAAE,IAAcqF,KAAKT,KAC5C7C,IACIuD,GACGA,EAAE,IAET/C,KAAK,KACFwC,QAAQQ,KAAK,2BAA4BX,GAClC3B,GACP5C,GAA0BA,GAEtCuD,CAACZ,IAAsB,IAYrBwC,GACFtD,GAJmBR,GACnB4B,MAAMC,QAAQ7B,GAAKwD,EAAYxD,GAPN,CAACA,GAC1BqD,QAAQC,MACJ,mGACAtD,GAIgC+D,CAAqB/D,IAshBpClC,EAAA0F,YAAAM,EAhhBzB,MAAME,EAAkBhE,GACnBA,EAAUoB,GACLpB,EACAyC,GACIE,QAASzB,EAAAX,MAAMC,GAAGR,GAClB4C,KAAMI,MACNF,KAAMR,MACNO,IAAKpB,MACLiB,UAAetC,GAASA,EACxB2C,YAAaS,IAAc,GAAIrC,OAoBvCsB,EAAWzC,KAEbiE,QAAU3D,IACN,MAAM4D,EAAc5D,EAAUkB,GACvBlB,EAAoB6C,UACrB7C,EAEA6D,EAA8B,mBAAfD,EACfD,EAAUE,EAAQD,EAAalE,EAAE+C,YAAYU,KAAKS,GAClDE,EAASD,EAASD,EAAwBrF,KAAOqF,EAUjDG,EACiB,mBAAZJ,EAAyBA,EAAQjE,EAAE2C,QAAQ/B,WAEtD,OAAOyD,EAAgBjC,QACnBiC,EAAgBlC,QAChBkC,EAAgBjD,GACdiD,EAAgB7B,OAAOxC,EAAGoE,EAAQ3B,GAdhB,CAAC6B,IACrBjB,QAAQQ,KACJ,mEACAO,GAEJf,QAAQQ,KAAK,gBAAiBS,GACvB7B,EAAQzC,IASbuE,EAAiBF,EAAiBD,KAG5CI,WAAY,CACRlE,EACAhC,IAEAA,EAAEmG,OACE,CAACC,EAAKC,KACF,MAAMT,EAAc5D,EAAUkB,GACvBlB,EAAoB6C,UACrB7C,EACA6D,EAA8B,mBAAfD,EACfD,EAAUE,EACVD,EACAlE,EAAE+C,YAAYU,KAAKS,GACnBE,EAASD,EACRD,EAAwBrF,KACzBqF,EAUAG,EACiB,mBAAZJ,EACDA,EAAQU,EAARV,CAAYS,EAAI9D,OAAO+B,QAAQ/B,WAIzC,OAAOyD,EAAgBjC,QACnBiC,EAAgBlC,QAChBkC,EAAgBjD,GACdiD,EAAgB7B,OAAOkC,EAAI9D,OAAQwD,EAAQ3B,GAjBzB,CAAC6B,IACrBjB,QAAQQ,KACJ,mEACAO,GAEJf,QAAQQ,KAAK,gBAAiBS,GACvBI,GAYLH,EAAiBF,EAAiBD,KAI5C3B,GACIE,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,eAI3B6B,MAAQ1B,GACJT,GACIE,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAW1C,EAAE0C,UACbK,YAAaG,IAIrBR,UAAYpC,GACRmC,GACIE,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAWpC,EACXyC,YAAa/C,EAAE+C,cAGvB5C,QAAS,eACMH,EAAE4C,KAAKzC,aAAaH,EAAE8C,KAAK3C,aAAaH,EAAE6C,IAAI1C,YAG7D0E,KAAM,IACFpC,GACIE,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAMI,EAAKhD,EAAE8C,KAAKlC,QAClBkC,KAAMR,EAAKtC,EAAE4C,KAAKhC,QAClB8B,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAIvB+B,OACIxE,GAEAmC,GACIE,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAMI,EAAK1C,EAAEN,EAAE4C,KAAKhC,SACpBkC,KAAMR,EAAKhC,EAAEN,EAAE8C,KAAKlC,SACpB8B,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAIvB1C,IAAMC,GAA8B0D,EAAe1D,EAAEN,IACrDS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBW,MAAQL,GAAgBA,EAAEN,GAC1BY,KAAM,IAAoBZ,EAG1B+E,WAAazE,GACTN,EAAE4C,KAAKhC,OAAOkB,OAASW,EAAQnC,EAAEN,IAAMyC,EAAQzC,GAGnDgF,UAAY1E,GACRN,EAAE8C,KAAKlC,OAAOkB,OAASW,EAAQnC,EAAEN,IAAMyC,EAAQzC,GAGnDwC,OAAQ,CAAClE,EAAiBiB,EAAWa,KACjC9B,EAAEoE,WAAWnD,EAAGkD,EAAQzC,KACjByC,GACHE,QAASrE,EAAEqE,QACXE,IAAKvE,EAAEuE,IACPD,KAAMtE,EAAEsE,KAAKlB,OAAO1B,EAAE4C,MACtBE,KAAMxE,EAAEwE,KAAKpB,OAAO1B,EAAE8C,MACtBJ,UAAWpE,EAAEoE,UACbK,YAAazE,EAAEyE,eAOvBkC,SAAU,CAAC3E,EAAaQ,MACpB6B,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAMtC,EAAEN,EAAE4C,MACVE,KAAMhC,EAAEd,EAAE8C,MACVJ,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAInBmC,QAAU5E,GAAiBN,EAAE4C,KAAKZ,UAAY1B,EAAEN,EAAE8C,WAAQ3B,EAG1DgE,QAAU7E,GAAiBN,EAAE4C,KAAKZ,eAAYb,EAASb,EAAEN,EAAE4C,MAG3DwC,QAAU9E,GAAiBN,EAAE8C,KAAKd,eAAYb,EAASb,EAAEN,EAAE8C,MAG3DuC,QAAU/E,GAAiBN,EAAE8C,KAAKd,UAAY1B,EAAEN,EAAE4C,WAAQzB,EAG1DN,KAAM,CAACP,EAAaQ,IAChBd,EAAE4C,KAAKhC,OAAOkB,OAASxB,EAAEN,EAAE4C,MAAQ9B,EAAEd,EAAE8C,MAG3CP,KAAM,CAACjC,EAAaQ,IAChBd,EAAE8C,KAAKlC,OAAOkB,OAASxB,EAAEN,EAAE8C,MAAQhC,EAAEd,EAAE4C,MAG3C0C,IAAMhF,GAA4BA,EAAEN,EAAE4C,KAAKhC,OAAOc,OAAO1B,EAAE8C,KAAKlC,SAGhEsB,CAACd,IAAkB,IAGjBmE,GACF5C,QAASqB,EACTxD,GA3MeR,GACf,YAAaA,GACb,SAAUA,GACV,SAAUA,GACV,QAASA,GACT,cAAeA,EACTyC,EAAQzC,GAdI,CAAIA,IACtBqD,QAAQQ,KACJ,yGAEGG,EAAehE,IAWhBwF,CAAcxF,IAmfHlC,EAAA2E,QAAA8C,EA5SrB,MAAME,EAAmBzF,GACpBA,EAAUoB,GACLpB,EACA0F,GACI/C,QAASzB,EAAAX,MAAMC,GAAGR,GAClB4C,KAAMI,MACNF,KAAMR,MACNO,IAAKpB,MACLiB,UAAetC,GAASA,EACxB2C,YAAaS,IAAc,GAAIrC,OAUvCwE,EAAc3F,GAChB,YAAaA,GACb,SAAUA,GACV,SAAUA,GACV,QAASA,GACT,cAAeA,EACT0F,EAAS1F,GAbI,CAAIA,IACvBqD,QAAQQ,KACJ,2GAEG4B,EAAgBzF,IAUjB4F,CAAe5F,GAEnB6F,EAAe7F,GACjB8F,GAEAA,EAAKrB,OACD,CAACsB,EAAKC,IAAQA,EAAIxD,OAAOuD,EAAK,aAAcL,GAAU9E,OACtDZ,GAGF0F,EAAY1F,KAEdiE,QAAU3D,IACN,MAAM4D,EAAc5D,EAAUkB,GACvBlB,EAAoB6C,UACrB7C,EACA6D,EAA8B,mBAAfD,EACfD,EAAUE,EAAQD,EAAalE,EAAE+C,YAAYU,KAAKS,GAClDE,EAASD,EAASD,EAAwBrF,KAAOqF,EAWjDG,EACiB,mBAAZJ,EAAyBA,EAAQjE,EAAE2C,QAAQ/B,WAOtD,OAAOyD,EAAgB4B,KACjBP,GACI/C,QAAS3C,EAAE2C,QACXC,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRD,IAAK7C,EAAE6C,IAAInB,OAAOD,GAAK4C,KACvB3B,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAZA,CAACmD,GACtBA,EAAS9D,QAAU8D,EAAS/D,QAAU+D,EAAS9E,GACzC8E,EAAS1D,OAAOxC,EAAGoE,EAAQsB,GAdb,CAACpB,IACrBjB,QAAQQ,KACJ,mEACAO,GAEJf,QAAQQ,KAAK,gBAAiBS,GACvB7B,EAAQzC,IASTuE,EAAiBF,EAAiBD,IAWtC+B,CAAiB9B,IAG3BG,WAAY,CACRlE,EACAhC,IAEAA,EAAEmG,OACE,CAACC,EAAKC,KACF,MAAMT,EAAc5D,EAAUkB,GACvBlB,EAAoB6C,UACrB7C,EACA6D,EAA8B,mBAAfD,EACfD,EAAUE,EAAQD,EAAalE,EAAE+C,YAAYU,KAAKS,GAClDE,EAASD,EAASD,EAAwBrF,KAAOqF,EAUjDG,EACiB,mBAAZJ,EACDA,EAAQU,EAARV,CAAYS,EAAI9D,OAAO+B,QAAQ/B,WAUzC,OAAOyD,EAAgB4B,KACjBP,GACI/C,QAAS+B,EAAI9D,OAAO+B,QACpBC,KAAM8B,EAAI9D,OAAOgC,KACjBE,KAAM4B,EAAI9D,OAAOkC,KACjBD,IAAK6B,EAAI9D,OAAOiC,IAAInB,OAAOD,GAAK4C,KAChC3B,UAAWgC,EAAI9D,OAAO8B,UACtBK,YAAa2B,EAAI9D,OAAOmC,cAdT,CAACmD,GACtBA,EAAS9D,QACT8D,EAAS/D,QACT+D,EAAS9E,GACH8E,EAAS1D,OAAOkC,EAAI9D,OAAQwD,EAAQsB,GACpCpD,EAAK4D,GAAU1D,OAAOxC,EAAGoE,EAAQsB,GAWrCS,CAAiB9B,IAI3BqB,GACI/C,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,eAI3B6B,MAAQ1B,GACJwC,GACI/C,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAW1C,EAAE0C,UACbK,YAAaG,IAIrBR,UAAYpC,GACRoF,GACI/C,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAM5C,EAAE4C,KACRE,KAAM9C,EAAE8C,KACRJ,UAAWpC,EACXyC,YAAa/C,EAAE+C,cAGvB5C,QAAS,gBACOH,EAAE4C,KAAKzC,aAAaH,EAAE8C,KAAK3C,aAAaH,EAAE6C,IAAI1C,YAG9D0E,KAAM,IACFa,GACI/C,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAMI,EAAKhD,EAAE8C,KAAKlC,QAClBkC,KAAMR,EAAKtC,EAAE4C,KAAKhC,QAClB8B,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAIvB+B,OACIxE,GAEAoF,GACI/C,QAAS3C,EAAE2C,QACXE,IAAK7C,EAAE6C,IACPD,KAAMI,EAAK1C,EAAEN,EAAE4C,KAAKhC,SACpBkC,KAAMR,EAAKhC,EAAEN,EAAE8C,KAAKlC,SACpB8B,UAAW1C,EAAE0C,UACbK,YAAa/C,EAAE+C,cAIvB1C,IAAMC,GAA8BmF,EAAgBnF,EAAEN,IACtDS,GAAKC,GAAaA,EAAEL,IAAIL,GACxBW,MAAQL,GAAgBA,EAAEN,GAC1BY,KAAM,IAAoBZ,EAG1B+E,WAAazE,GACTN,EAAE4C,KAAKhC,OAAOkB,OAASW,EAAQnC,EAAEN,IAAM0F,EAAS1F,GAGpDgF,UAAY1E,GACRN,EAAE8C,KAAKlC,OAAOkB,OAASW,EAAQnC,EAAEN,IAAM0F,EAAS1F,GAGpDwC,OAAQ,CAAClE,EAAiBiB,EAAWa,KACjC9B,EAAEoE,WAAWnD,EAAGmG,EAAS1F,KAClB0F,GACH/C,QAASrE,EAAEqE,QACXE,IAAKvE,EAAEuE,IACPD,KAAMtE,EAAEsE,KAAKlB,OAAO1B,EAAE4C,MACtBE,KAAMxE,EAAEwE,KAAKpB,OAAO1B,EAAE8C,MACtBJ,UAAWpE,EAAEoE,UACbK,YAAazE,EAAEyE,eAQvBkC,SAAU,CAAO3E,EAAaQ,IAAsCsF,EAAAC,UAAA,qBAChE,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,KACFiC,QAASjC,EAAEiC,QACXE,IAAKnC,EAAEmC,IACPD,KAAMtC,EAAEI,EAAEkC,MACVE,KAAMhC,EAAEJ,EAAEoC,MACVJ,UAAWhC,EAAEgC,UACbK,YAAarC,EAAEqC,iBAI3BmC,QAAgB5E,GAAmD8F,EAAAC,UAAA,qBAC/D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEkC,KAAKZ,UAAY1B,EAAEI,EAAEoC,WAAQ3B,GAC1CqF,MAAMC,GAAOpD,QAAQC,MAAM,MAAOmD,MAG3CtB,QAAgB7E,GAAmD8F,EAAAC,UAAA,qBAC/D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEkC,KAAKZ,eAAYb,EAASb,EAAEI,EAAEkC,SAGpDwC,QAAgB9E,GAAmD8F,EAAAC,UAAA,qBAC/D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEoC,KAAKd,eAAYb,EAASb,EAAEI,EAAEoC,OAC3C0D,MAAMC,GAAOpD,QAAQC,MAAM,MAAOmD,MAG3CpB,QAAgB/E,GAAmD8F,EAAAC,UAAA,qBAC/D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEoC,KAAKd,UAAY1B,EAAEI,EAAEkC,WAAQzB,KAGnDN,KAAM,CAAOP,EAAaQ,IAAoCsF,EAAAC,UAAA,qBAC1D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEkC,KAAKhC,OAAOkB,OAASxB,EAAEI,EAAEkC,MAAQ9B,EAAEJ,EAAEoC,SAG3DP,KAAM,CAAOjC,EAAaQ,IAAoCsF,EAAAC,UAAA,qBAC1D,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAMA,EAAEoC,KAAKlC,OAAOkB,OAASxB,EAAEI,EAAEoC,MAAQhC,EAAEJ,EAAEkC,SAG3D0C,IAAYhF,GAAoC8F,EAAAC,UAAA,qBAC5C,OAAAC,QAAQC,IAAIvG,EAAE6C,IAAIjC,QACbqF,KAAKJ,EAAS7F,IACdiG,KAAK3H,GAAMA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAC3C2H,KAAKvF,GAAKJ,EAAEI,EAAEkC,KAAKhC,OAAOc,OAAOhB,EAAEoC,KAAKlC,YAGjD8F,MAAO,CAAOC,EAAYC,MAAmCR,EAAAC,UAAA,qBAEzD,MAAMQ,EAAY,IAAIP,QAAQ,CAACQ,EAASC,IACpCC,WAAWF,EAASH,GAAI3D,EAAK,gCAE3BiE,EAAgBX,QAAQC,IAAIvG,EAAE6C,IAAIjC,QAExC,OACI0F,QAAQY,MAAML,EAAWI,IAEpBhB,KAAKJ,EAAS7F,IACdiG,KAAM3H,GAAYA,EAAE8C,GAAmB9C,EAAEsC,OAAStC,GAClD2H,KAAMvF,GAAWiF,EAAWjF,MAIzCwB,CAACd,IAAkB,IAGjB+F,GACFxE,QAAS8C,EACTjF,GAAImF,GAKc7H,EAAA4H,SAAAyB","file":"inquiry-monad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonad\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonad\"] = factory();\n\telse\n\t\troot[\"InquiryMonad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","import { Maybe } from 'simple-maybe';\nimport {\n    Monad,\n    InquiryMonad,\n    IOUMonad,\n    PassFailMonad,\n    PassMonad,\n    FailMonad,\n    InquiryValue,\n    QuestionsetMonad,\n    QuestionMonad\n} from './inquiry-monad';\n\nconst noop = () => {};\n\nconst $$inquirySymbol: unique symbol = Symbol();\nconst $$questionsetSymbol: unique symbol = Symbol();\nconst $$notFoundSymbol: unique symbol = Symbol();\nconst $$questionSymbol: unique symbol = Symbol();\n\nconst IOU = <T>(x: T | Array<T>): IOUMonad => ({\n    map: (f: Function) => IOU(f(x)),\n    chain: (f: Function) => f(x),\n    ap: (y: Monad) => y.map(x),\n    inspect: () => <string>`IOU(${x})`,\n    join: () => x,\n    concat: (o: IOUMonad) =>\n        o.chain((r: any) => IOU((x as Array<T>).concat(r))),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    // @ts-ignore no support yet for symbols as property names\n    [$$inquirySymbol]: false,\n    isPass: false,\n    isFail: false,\n    isIOU: true\n});\n\nconst Pass = <T>(x: Array<T> | T): PassMonad => ({\n    map: (f: Function) => Pass(f(x)),\n    chain: (f: Function) => f(x),\n    fold: (f: Function, _: Function) => f(x),\n    fork: (_: Function, f: Function) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => <string>`Pass(${x})`,\n    concat: (o: PassFailMonad) =>\n        o.fold((r: any) => Pass((x as Array<T>).concat(r)), null),\n    ap: (y: PassFailMonad) => (y.isPass ? y.concat(Pass(x)) : Pass(x)),\n    answer: (\n        i: InquiryValue,\n        n: string = '(anonymous)',\n        c: Function = Inquiry\n    ): InquiryMonad => {\n        i.informant([n, Pass(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail,\n            iou: i.iou,\n            pass: i.pass.concat(Pass(x)),\n            informant: i.informant,\n            questionset: i.questionset\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: true,\n    isFail: false,\n    isIOU: false,\n    // @ts-ignore\n    [$$inquirySymbol]: false\n});\n\nconst Fail = <T>(x: Array<T> | T): FailMonad => ({\n    map: (f: Function) => Fail(f(x)),\n    chain: (f: Function) => f(x),\n    fold: (_: Function, f: Function) => f(x),\n    fork: (f: Function, _: Function) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => <string>`Fail(${x})`,\n    concat: (o: PassFailMonad) =>\n        o.fork((r: any) => Fail((x as Array<T>).concat(r)), null),\n    ap: (y: PassFailMonad) => (y.isPass ? Fail(x) : y.concat(Fail(x))),\n    answer: (\n        i: InquiryValue,\n        n: string = '(anonymous)',\n        c: Function = Inquiry\n    ): InquiryMonad => {\n        i.informant([n, Fail(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail.concat(Fail(x)),\n            pass: i.pass,\n            iou: i.iou,\n            informant: i.informant,\n            questionset: i.questionset\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: false,\n    isFail: true,\n    isIOU: false,\n    // @ts-ignore\n    [$$inquirySymbol]: false\n});\n\nconst questionTypeError = (x: any) =>\n    console.error(\n        'Question must be passed parameters that adhere to the documented type. Value that was passed:',\n        x\n    );\n\nconst Question = (x: Array<string | Function | RegExp>): QuestionMonad => ({\n    map: (f: Function) => Question(f(x)),\n    chain: (f: Function) => f(x),\n    ap: (y: Monad) => y.map(x),\n    inspect: () => <string>`Question(${x})`,\n    join: () => x,\n    call: (a: InquiryMonad) => (x[1] as Function)(a.join().subject.join()),\n    extract: () => x[1],\n    //@ts-ignore\n    [$$questionSymbol]: true\n});\n\nconst QuestionOf = (x: Array<string | Function | RegExp>) =>\n    Array.isArray(x) ? Question(x) : questionTypeError(x);\n\nconst exportQuestion = {\n    of: QuestionOf\n};\n\nconst Questionset = (\n    x: Array<Array<string | Function | RegExp>>\n): QuestionsetMonad => ({\n    map: (f: Function) => Questionset(f(x)),\n    chain: (f: Function) => f(x),\n    ap: (y: Monad) => y.map(x),\n    inspect: () => <string>`Questionset(${x})`,\n    join: () => x,\n    find: (a: string) =>\n        Maybe.of(x.find(i => RegExp(i[0] as string).test(a)))\n            .map(\n                (b: Array<string | Function | RegExp>): Function =>\n                    b[1] as Function\n            )\n            .fork((): symbol => {\n                console.warn('Question was not found: ', a);\n                return $$notFoundSymbol;\n            }, (c: Function): Function => c),\n    // @ts-ignore\n    [$$questionsetSymbol]: true\n});\n\nconst questionsetTypeError = (x: any) =>\n    console.error(\n        'Questionset must be passed parameters that adhere to the documented type. Value that was passed:',\n        x\n    );\n\nconst QuestionsetOf = (x: Array<Array<string | Function | RegExp>>) =>\n    Array.isArray(x) ? Questionset(x) : questionsetTypeError(x);\n\nconst exportQuestionset = {\n    of: QuestionsetOf\n};\n\nconst InquirySubject = (x: any | InquiryMonad): InquiryMonad =>\n    (x as any)[$$inquirySymbol]\n        ? x\n        : Inquiry({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset([['', noop]])\n          });\n\nconst warnTypeError = <T>(x: T) => {\n    console.warn(\n        'Inquiry.of requires properties: subject, fail, pass, iou, informant. Converting to Inquiry.subject().'\n    );\n    return InquirySubject(x);\n};\n\n// @todo validate constructor via Symbol\nconst InquiryOf = (x: InquiryValue) =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x\n        ? Inquiry(x)\n        : warnTypeError(x);\n\nconst Inquiry = (x: InquiryValue): InquiryMonad => ({\n    // Inquire: core method\n    inquire: (f: Function | string | QuestionMonad) => {\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn ? fExtractFn : x.questionset.find(fExtractFn);\n        const fnName = fIsFn ? (fExtractFn as Function).name : fExtractFn;\n\n        const warnNotPassFail = (resp: any) => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            console.warn('response was:', resp);\n            return Inquiry(x);\n        };\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        return inquireResponse.isFail ||\n            inquireResponse.isPass ||\n            inquireResponse[$$inquirySymbol]\n            ? inquireResponse.answer(x, fnName, Inquiry)\n            : warnNotPassFail([inquireResponse, fnName]);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn\n                    ? fExtractFn\n                    : x.questionset.find(fExtractFn);\n                const fnName = fIsFn\n                    ? (fExtractFn as Function).name\n                    : fExtractFn;\n\n                const warnNotPassFail = (resp: any) => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    console.warn('response was:', resp);\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                // each return aggregates new contained value through exit\n                return inquireResponse.isFail ||\n                    inquireResponse.isPass ||\n                    inquireResponse[$$inquirySymbol]\n                    ? inquireResponse.answer(inq.join(), fnName, Inquiry)\n                    : warnNotPassFail([inquireResponse, fnName]);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            Inquiry({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset\n            })\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset\n        }),\n\n    inspect: (): string =>\n        `Inquiry(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap pass/fail\n    swap: (): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort)\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset\n        }),\n\n    // standard Monad methods\n    map: (f: Function): InquiryMonad => InquirySubject(f(x)),\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) =>\n        x.fail.join().length ? Inquiry(f(x)) : Inquiry(x),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) =>\n        x.pass.join().length ? Inquiry(f(x)) : Inquiry(x),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function) => {\n        i.informant([n, Inquiry(x)]);\n        return Inquiry({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset\n        });\n    },\n\n    // Unwrap methods\n\n    // unwraps, mapping for both branches, full value returned\n    conclude: (f: Function, g: Function): InquiryValue => ({\n        subject: x.subject,\n        iou: x.iou,\n        fail: f(x.fail),\n        pass: g(x.pass),\n        informant: x.informant,\n        questionset: x.questionset\n    }),\n\n    // If there are no fails, handoff aggregated passes to supplied function; if any fails, return noop\n    cleared: (f: Function) => (x.fail.isEmpty() ? f(x.pass) : noop()),\n\n    // If there are fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: (f: Function) => (x.fail.isEmpty() ? noop() : f(x.fail)),\n\n    // If there are passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: (f: Function) => (x.pass.isEmpty() ? noop() : f(x.pass)),\n\n    // If there are no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: (f: Function) => (x.pass.isEmpty() ? f(x.fail) : noop()),\n\n    // unwrap left if any fails, right if not\n    fork: (f: Function, g: Function) =>\n        x.fail.join().length ? f(x.fail) : g(x.pass),\n\n    // unwrap left if any passes, right if not\n    fold: (f: Function, g: Function) =>\n        x.pass.join().length ? f(x.pass) : g(x.fail),\n\n    // return a merged pass/fail\n    zip: (f: Function): Array<any> => f(x.fail.join().concat(x.pass.join())), // return a concat of pass/fails\n\n    // @ts-ignore\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiry = {\n    subject: InquirySubject,\n    of: InquiryOf\n};\n\nconst InquiryPSubject = (x: any | InquiryMonad): InquiryMonad =>\n    (x as any)[$$inquirySymbol]\n        ? x\n        : InquiryP({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset([['', noop]])\n          });\n\nconst warnTypeErrorP = <T>(x: T) => {\n    console.warn(\n        'InquiryP.of requires properties: subject, fail, pass, iou, informant. Converting to InquiryP.subject().'\n    );\n    return InquiryPSubject(x);\n};\n\nconst InquiryPOf = (x: InquiryValue) =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x\n        ? InquiryP(x)\n        : warnTypeErrorP(x);\n\nconst buildInq = <T>(x: T) => (\n    vals: Array<any> // @todo find a way to produce fn name\n) =>\n    vals.reduce(\n        (acc, cur) => cur.answer(acc, '(async fn)', InquiryP).join(),\n        x\n    );\n\nconst InquiryP = (x: InquiryValue): InquiryMonad => ({\n    // Inquire: core method\n    inquire: (f: Function | string | QuestionMonad) => {\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn ? fExtractFn : x.questionset.find(fExtractFn);\n        const fnName = fIsFn ? (fExtractFn as Function).name : fExtractFn;\n\n        const warnNotPassFail = (resp: any) => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            console.warn('response was:', resp);\n            return Inquiry(x);\n        };\n\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        const syncronousResult = (response: any) =>\n            response.isFail || response.isPass || response[$$inquirySymbol]\n                ? response.answer(x, fnName, InquiryP)\n                : warnNotPassFail([inquireResponse, fnName]);\n\n        return inquireResponse.then\n            ? InquiryP({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireResponse])),\n                  informant: x.informant,\n                  questionset: x.questionset\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn ? fExtractFn : x.questionset.find(fExtractFn);\n                const fnName = fIsFn ? (fExtractFn as Function).name : fExtractFn;\n\n                const warnNotPassFail = (resp: any) => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    console.warn('response was:', resp);\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                const syncronousResult = (response: any) =>\n                    response.isFail ||\n                    response.isPass ||\n                    response[$$inquirySymbol]\n                        ? response.answer(inq.join(), fnName, InquiryP)\n                        : Pass(response).answer(x, fnName, InquiryP);\n\n                return inquireResponse.then\n                    ? InquiryP({\n                          subject: inq.join().subject,\n                          fail: inq.join().fail,\n                          pass: inq.join().pass,\n                          iou: inq.join().iou.concat(IOU([inquireResponse])),\n                          informant: inq.join().informant,\n                          questionset: inq.join().questionset\n                      })\n                    : syncronousResult(inquireResponse);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            InquiryP({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset\n            })\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset\n        }),\n\n    inspect: (): string =>\n        `InquiryP(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): InquiryMonad => InquiryPSubject(f(x)), // cast required for now\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) =>\n        x.fail.join().length ? Inquiry(f(x)) : InquiryP(x),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) =>\n        x.pass.join().length ? Inquiry(f(x)) : InquiryP(x),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryP(x)]);\n        return InquiryP({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset\n        });\n    },\n\n    // Unwrapping methods: all return Promises, all complete outstanding IOUs\n\n    // @todo handle Promise.reject? Is it a failure or what?\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: async (f: Function, g: Function): Promise<InquiryValue> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => ({\n                subject: y.subject,\n                iou: y.iou,\n                fail: f(y.fail),\n                pass: g(y.pass),\n                informant: y.informant,\n                questionset: y.questionset\n            })),\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return noop\n    cleared: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? f(y.pass) : noop()))\n            .catch(err => console.error('err', err)),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? noop() : f(y.fail))),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? noop() : f(y.pass)))\n            .catch(err => console.error('err', err)),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? f(y.fail) : noop())),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: async (f: Function, g: Function): Promise<Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.join().length ? f(y.fail) : g(y.pass))),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fold: async (f: Function, g: Function): Promise<Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.join().length ? f(y.pass) : g(y.fail))),\n\n    // return a Promise containing a merged fail/pass resultset array\n    zip: async (f: Function): Promise<Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => f(y.fail.join().concat(y.pass.join()))),\n\n    // await all IOUs to resolve, then return a new Inquiry CONVERTS TO PROMISE!\n    await: async (t: number = Infinity): Promise<InquiryMonad> => {\n        // try: generator function. Each IOU = array in for loop as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\n        const timeLimit = new Promise((resolve, reject) =>\n            setTimeout(resolve, t, [Fail('Promise(s) have timed out')])\n        );\n        const awaitPromises = Promise.all(x.iou.join());\n\n        return (\n            Promise.race([timeLimit, awaitPromises])\n                // @ts-ignore\n                .then(buildInq(x))\n                .then((i: any) => (i[$$inquirySymbol] ? i.join() : i))\n                .then((y: any) => InquiryPOf(y))\n        );\n    },\n    // @ts-ignore\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiryP = {\n    subject: InquiryPSubject,\n    of: InquiryPOf\n};\n\nexport {\n    exportInquiry as Inquiry,\n    exportInquiryP as InquiryP,\n    exportQuestionset as Questionset,\n    exportQuestion as Question,\n    Fail,\n    Pass,\n    IOU,\n    $$inquirySymbol,\n    $$questionsetSymbol\n};\n"],"sourceRoot":""}