{"version":3,"sources":["webpack://InquiryMonad/webpack/universalModuleDefinition","webpack://InquiryMonad/webpack/bootstrap","webpack://InquiryMonad/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","simple_maybe_1","IOU","concat","head","Array","isArray","length","tail","isEmpty","Boolean","isInquiry","isPass","isFail","isIOU","Pass","fold","answer","Inquiry","informant","subject","fail","iou","pass","Fail","InquirySubject","inquire","inquireResponse","swap","unison","breakpoint","milestone","conclude","cleared","faulted","suffice","scratch","zip","exportInquiry","console","warn","warnTypeError","InquiryPSubject","InquiryP","InquiryPOf","warnTypeErrorP","buildInq","vals","reduce","acc","cur","then","response","syncronousResult","__awaiter","this","Promise","all","catch","err","error","await","t","Infinity","timeLimit","resolve","reject","setTimeout","awaitPromises","race","exportInquiryP"],"mappings":"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","file":"inquiry-monad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonad\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonad\"] = factory();\n\telse\n\t\troot[\"InquiryMonad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","import { Maybe } from 'simple-maybe';\n\nconst IOU = <T>(x: T | Array<T>): IOUMonad => ({\n    map: (f: Function) => IOU(f(x)),\n    chain: (f: Function) => f(x),\n    ap: (y: Monad) => y.map(x),\n    inspect: () => <string>`IOU(${x})`,\n    join: () => x,\n    concat: (o: IOUMonad) =>\n        o.chain((r: any) => IOU((x as Array<T>).concat(r))),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isInquiry: false,\n    isPass: false,\n    isFail: false,\n    isIOU: true\n});\n\nconst Pass = <T>(x: Array<T> | T): PassMonad => ({\n    map: (f: Function) => Pass(f(x)),\n    chain: (f: Function) => f(x),\n    fold: (f: Function, _: Function) => f(x),\n    fork: (_: Function, f: Function) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => <string>`Pass(${x})`,\n    concat: (o: PassFailMonad) =>\n        o.fold((r: any) => Pass((x as Array<T>).concat(r)), null),\n    ap: (y: PassFailMonad) => (y.isPass ? y.concat(Pass(x)) : Pass(x)),\n    answer: (i: Inquiry, n: string = '(anonymous)', c: Function = Inquiry) => {\n        i.informant([n, Pass(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail,\n            iou: i.iou,\n            pass: i.pass.concat(Pass(x)),\n            informant: i.informant\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: true,\n    isFail: false,\n    isIOU: false,\n    isInquiry: false\n});\n\nconst Fail = <T>(x: Array<T> | T): FailMonad => ({\n    map: (f: Function) => Fail(f(x)),\n    chain: (f: Function) => f(x),\n    fold: (_: Function, f: Function) => f(x),\n    fork: (f: Function, _: Function) => f(x),\n    head: () => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: () => (Array.isArray(x) && x.length ? x[x.length - 1] : []),\n    join: () => x,\n    inspect: () => <string>`Fail(${x})`,\n    concat: (o: PassFailMonad) =>\n        o.fork((r: any) => Fail((x as Array<T>).concat(r)), null),\n    ap: (y: PassFailMonad) => (y.isPass ? Fail(x) : y.concat(Fail(x))),\n    answer: (i: Inquiry, n: string = '(anonymous)', c: Function = Inquiry) => {\n        i.informant([n, Fail(x)]);\n        return c({\n            subject: i.subject,\n            fail: i.fail.concat(Fail(x)),\n            pass: i.pass,\n            iou: i.iou,\n            informant: i.informant\n        });\n    },\n    isEmpty: () => Boolean(!Array.isArray(x) || x.length === 0),\n    isPass: false,\n    isFail: true,\n    isIOU: false,\n    isInquiry: false\n});\n\nconst InquirySubject = <T>(x: T | InquiryMonad) =>\n    (x as any).isInquiry\n        ? x\n        : Inquiry({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _\n          });\n\nconst warnTypeError = <T>(x: T) => {\n    console.warn('Inquiry.of requires properties: subject, fail, pass, iou, informant. Converting to Inquiry.subject().');\n    return InquirySubject(x);\n}\n\nconst InquiryOf = (x: Inquiry) =>\n    'subject' in x\n          && 'fail' in x\n          && 'pass' in x\n          && 'iou' in x\n          && 'informant' in x\n            ? Inquiry(x)\n            : warnTypeError(x);\n\n\nconst Inquiry = (x: Inquiry): InquiryMonad => ({\n    // Inquire: core method\n    inquire: (f: Function) => {\n        const inquireResponse = f(x.subject.join());\n        return inquireResponse.isFail ||\n            inquireResponse.isPass ||\n            inquireResponse.isInquiry\n            ? inquireResponse.answer(x, f.name, Inquiry)\n            : Pass(inquireResponse);\n    },\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f\n        }),\n\n    inspect: (): string =>\n        `Inquiry(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap pass/fail\n    swap: (): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort)\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant\n        }),\n\n    // standard Monad methods\n    map: (f: Function): Inquiry => InquirySubject(f(x)),\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): Inquiry => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) => (x.fail.join().length ? f(x) : Inquiry(x)),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) => (x.pass.join().length ? f(x) : Inquiry(x)),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: Inquiry, n: string, _: Function) => {\n        i.informant([n, Inquiry(x)]);\n        return Inquiry({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant\n        });\n    },\n\n    // Unwrap methods\n\n    // unwraps, mapping for both branches, full value returned\n    conclude: (f: Function, g: Function): Inquiry => ({\n        subject: x.subject,\n        iou: x.iou,\n        fail: f(x.fail),\n        pass: g(x.pass),\n        informant: x.informant\n    }),\n\n    // If there are no fails, handoff aggregated passes to supplied function; if any fails, return existing Inquiry\n    cleared: (f: Function) => (x.fail.isEmpty() ? f(x.pass) : Inquiry(x)),\n\n    // If there are fails, handoff aggregated fails to supplied function; if no fails, return existing Inquiry\n    faulted: (f: Function) => (x.fail.isEmpty() ? Inquiry(x) : f(x.fail)),\n\n    // If there are passes, handoff aggregated passes to supplied function; if no passes, return existing Inquiry\n    suffice: (f: Function) => (x.pass.isEmpty() ? Inquiry(x) : f(x.pass)),\n\n    // If there are no passes, handoff aggregated passes to supplied function; if any passes, return existing Inquiry\n    scratch: (f: Function) => (x.pass.isEmpty() ? f(x.pass) : Inquiry(x)),\n\n    // unwrap left if any fails, right if not\n    fork: (f: Function, g: Function) =>\n        x.fail.join().length ? f(x.fail) : g(x.pass),\n\n    // return a merged pass/fail\n    zip: (f: Function): Array<any> => f(x.fail.join().concat(x.pass.join())), // return a concat of pass/fails\n\n    isInquiry: true\n});\n\nconst exportInquiry = {\n    subject: InquirySubject,\n    of: InquiryOf\n};\n\nconst InquiryPSubject =<T> (x: T | InquiryMonad) =>\n    (x as any).isInquiry\n        ? x\n        : InquiryP({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _\n          });\n\nconst warnTypeErrorP = <T>(x: T) => {\n    console.warn('InquiryP.of requires properties: subject, fail, pass, iou, informant. Converting to InquiryP.subject().');\n    return InquiryPSubject(x);\n}\n\nconst InquiryPOf = (x: Inquiry) =>\n    'subject' in x\n        && 'fail' in x\n        && 'pass' in x\n        && 'iou' in x\n        && 'informant' in x\n            ? InquiryP(x)\n            : warnTypeErrorP(x);\n\nconst buildInq = <T>(x: T) => (vals: Array<any>) => // @todo find a way to produce fn name\n    vals.reduce((acc, cur) => cur.answer(x, '(async fn)', InquiryP), x);\n\nconst InquiryP = (x: Inquiry): InquiryMonad => ({\n    // Inquire: core method\n    inquire: (f: Function) => {\n        const inquireResponse = f(x.subject.join());\n        const syncronousResult = (response: any) =>\n            response.isFail || response.isPass || response.isInquiry\n                ? response.answer(x, f.name, InquiryP)\n                : Pass(response);\n\n        return inquireResponse.then\n            ? InquiryP({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireResponse])),\n                  informant: x.informant\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function) =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f\n        }),\n\n    inspect: (): string =>\n        `InquiryP(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): Inquiry => InquiryPSubject(f(x)), // cast required for now\n    ap: (y: Monad) => y.map(x),\n    chain: (f: Function) => f(x),\n    join: (): Inquiry => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function) => (x.fail.join().length ? f(x) : InquiryP(x)),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function) => (x.pass.join().length ? f(x) : InquiryP(x)),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: Inquiry, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryP(x)]);\n        return InquiryP({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant\n        });\n    },\n\n    // Unwrapping methods: all return Promises, all complete outstanding IOUs\n\n    // @todo handle Promise.reject? Is it a failure or what?\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: async (f: Function, g: Function): Promise<Inquiry> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => ({\n                subject: y.subject,\n                iou: y.iou,\n                fail: f(y.fail),\n                pass: g(y.pass),\n                informant: y.informant\n            })),\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return existing InquiryP\n    cleared: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? f(y.pass) : InquiryP(y)))\n            .catch(err => console.error('err', err)),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return existing InquiryP\n    faulted: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? InquiryP(y) : f(y.fail))),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return existing InquiryP\n    suffice: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? InquiryP(y) : f(y.pass)))\n            .catch(err => console.error('err', err)),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return existing InquiryP\n    scratch: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? f(y.pass) : InquiryP(y))),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: async (f: Function, g: Function): Promise<Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => (y.fail.join().length ? f(y.fail) : g(y.pass))),\n\n    // return a Promise containing a merged fail/pass resultset array\n    zip: async (f: Function): Promise<Array<any>> =>\n        Promise.all(x.iou.join())\n            .then(buildInq(x))\n            .then(i => (i.isInquiry ? i.join() : i))\n            .then(y => f(y.fail.join().concat(y.pass.join()))),\n\n    // await all IOUs to resolve, then return a new Inquiry CONVERTS TO PROMISE!\n    await: async (t: number = Infinity): Promise<InquiryMonad> => {\n\n        // try: generator function. Each IOU = array in for loop as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\n        const timeLimit = new Promise((resolve, reject) => setTimeout(resolve, t, [Fail('Promise(s) have timed out')]))\n        const awaitPromises = Promise.all(x.iou.join());\n\n        return Promise.race([timeLimit, awaitPromises])\n            // @ts-ignore\n            .then(buildInq(x))\n            .then((i: any) => (i.isInquiry ? i.join() : i))\n            .then((y: any) =>  InquiryPOf(y));\n    },\n    isInquiry: true\n});\n\nconst exportInquiryP = {\n    subject: InquiryPSubject,\n    of: InquiryPOf\n};\n\nexport {\n    exportInquiry as Inquiry,\n    exportInquiryP as InquiryP,\n    Fail,\n    Pass,\n    IOU\n};\n"],"sourceRoot":""}