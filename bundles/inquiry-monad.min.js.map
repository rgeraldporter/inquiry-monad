{"version":3,"sources":["webpack://InquiryMonad/webpack/universalModuleDefinition","webpack://InquiryMonad/webpack/bootstrap","webpack://InquiryMonad/./src/symbols.ts","webpack://InquiryMonad/./node_modules/simple-maybe/src/index.js","webpack://InquiryMonad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","$$inquirySymbol","Symbol","$$questionsetSymbol","$$questionSymbol","$$passSymbol","$$failSymbol","$$iouSymbol","$$receiptSymbol","Just","x","isJust","isNothing","inspect","_","map","f","Maybe","of","ap","y","chain","join","fork","g","sequence","Nothing","undefined","simple_maybe_1","symbols_1","noop","$$notFoundSymbol","PromiseEvery","promises","Promise","resolve","results","count","forEach","promise","idx","catch","err","then","valueOrError","length","IOU","concat","head","Array","isArray","tail","isEmpty","Boolean","[object Object]","Pass","fold","answer","Ix","Inquiry","informant","subject","fail","iou","pass","questionset","receipt","Receipt","Fail","Question","extract","QuestionOf","console","error","questionTypeError","exportQuestion","Questionset","find","a","RegExp","test","b","warn","exportQuestionset","questionsetTypeError","InquirySubject","inquire","fnName","extractName","fExtractFn","inquireResponse","resp","warnNotPassFail","inquireMap","reduce","inq","ii","inquireAll","questions","q","using","swap","unison","breakpoint","milestone","conclude","cleared","faulted","suffice","scratch","zip","exportInquiry","warnTypeError","InquiryPSubject","InquiryP","InquiryPOf","warnTypeErrorP","buildInq","vals","acc","cur","resolveQs","result","inquireIOU","response","syncronousResult","__awaiter","this","await","t","Infinity","timeLimit","reject","setTimeout","awaitPromises","race","exportInquiryP"],"mappings":"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","file":"inquiry-monad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"InquiryMonad\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InquiryMonad\"] = factory();\n\telse\n\t\troot[\"InquiryMonad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","export const $$inquirySymbol: unique symbol = Symbol();\nexport const $$questionsetSymbol: unique symbol = Symbol();\nexport const $$questionSymbol: unique symbol = Symbol();\nexport const $$passSymbol: unique symbol = Symbol();\nexport const $$failSymbol: unique symbol = Symbol();\nexport const $$iouSymbol: unique symbol = Symbol();\nexport const $$receiptSymbol: unique symbol = Symbol();","const Just = x => ({\n    isJust: true,\n    isNothing: false,\n    inspect: _ => `Just(${x})`,\n    map: f => Maybe.of(f(x)),\n    ap: y => y.map(x),\n    chain: f => f(x),\n    join: _ => x,\n    fork: (_, g) => g(x),\n    sequence: of => x.map(Maybe.of)\n});\n\nconst Nothing = _ => ({\n    isJust: false,\n    isNothing: true,\n    inspect: _ => `Nothing`,\n    map: _ => Nothing(),\n    ap: _ => Nothing(),\n    chain: _ => Nothing(),\n    join: _ => Nothing(),\n    fork: (f, _) => f(),\n    sequence: of => of(Nothing())\n});\n\nconst Maybe = {\n    of: x => x === null || x === undefined ? Nothing() : Just(x)\n};\n\nmodule.exports = {Maybe, Nothing, Just};","import { Maybe } from 'simple-maybe';\n\nimport {\n    Monad,\n    InquiryMonad,\n    IOUMonad,\n    PassFailMonad,\n    PassMonad,\n    FailMonad,\n    InquiryValue,\n    ReceiptMonad,\n    ReceiptValue,\n    QuestionsetMonad,\n    QuestionMonad,\n    QuestionValue,\n    InquiryConstructor,\n    QuestionMonadConstructor,\n    QuestionsetMonadConstructor\n} from './inquiry-monad';\n\nimport {\n    $$inquirySymbol,\n    $$questionsetSymbol,\n    $$questionSymbol,\n    $$passSymbol,\n    $$failSymbol,\n    $$iouSymbol,\n    $$receiptSymbol\n} from './symbols';\n\nconst noop = (): void => {};\n\nconst $$notFoundSymbol: unique symbol = Symbol('Not found');\n\n// like Promise.all without the fast reject functionality\nconst PromiseEvery = <T>(promises: Promise<T>[]): Promise<any[]> =>\n    new Promise((resolve: any) => {\n        const results: any[] = [];\n        let count: number = 0;\n        promises.forEach((promise: Promise<T>, idx: number) => {\n            promise\n                .catch(err => err) // pass errs down as (presumably) Fail\n                .then((valueOrError: any) => {\n                    results[idx] = valueOrError;\n                    count += 1;\n                    count === promises.length && resolve(results);\n                });\n        });\n    });\n\nconst IOU = (x: QuestionMonad | Array<QuestionMonad>): IOUMonad => ({\n    map: (f: Function): IOUMonad => IOU(f(x)),\n    chain: (f: Function): any => f(x),\n    ap: (y: Monad): Monad => y.map(x),\n    inspect: (): string => `IOU(${x})`,\n    join: (): QuestionMonad | Array<QuestionMonad> => x,\n    concat: (o: IOUMonad): IOUMonad =>\n        o.chain(\n            (r: any): IOUMonad => IOU((x as Array<QuestionMonad>).concat(r))\n        ),\n    head: (): QuestionMonad | Array<QuestionMonad> =>\n        Array.isArray(x) && x.length ? x[0] : [],\n    tail: (): QuestionMonad | Array<QuestionMonad> =>\n        Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    isEmpty: (): Boolean => Boolean(!Array.isArray(x) || x.length === 0),\n    [$$inquirySymbol]: false,\n    [$$passSymbol]: false,\n    [$$failSymbol]: false,\n    [$$iouSymbol]: true\n});\n\nconst Pass = <T>(x: Array<T> | T): PassMonad => ({\n    map: (f: Function): PassMonad => Pass(f(x)),\n    chain: (f: Function): any => f(x),\n    fold: (f: Function, _: Function): any => f(x),\n    fork: (_: Function, f: Function): any => f(x),\n    head: (): Array<T> | T => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: (): Array<T> | T =>\n        Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    join: (): Array<T> | T => x,\n    inspect: (): string => `Pass(${x})`,\n    concat: (o: PassFailMonad): PassFailMonad =>\n        o.fold((r: any): PassMonad => Pass((x as Array<T>).concat(r)), noop),\n    ap: (y: PassFailMonad): PassMonad =>\n        (y as any)[$$passSymbol] ? y.concat(Pass(x)) : Pass(x),\n    answer: (\n        i: InquiryValue,\n        n: string = '(anonymous)',\n        Ix: Function = Inquiry\n    ): InquiryMonad => {\n        i.informant([n, Pass(x)]);\n        return Ix({\n            subject: i.subject,\n            fail: i.fail,\n            iou: i.iou,\n            pass: i.pass.concat(Pass(x)),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt.concat(Receipt([[n, Pass(x)]]))\n        });\n    },\n    isEmpty: (): Boolean => Boolean(!Array.isArray(x) || x.length === 0),\n    [$$passSymbol]: true,\n    [$$failSymbol]: false,\n    [$$iouSymbol]: false,\n    [$$inquirySymbol]: false\n});\n\nconst Fail = <T>(x: Array<T> | T): FailMonad => ({\n    map: (f: Function): FailMonad => Fail(f(x)),\n    chain: (f: Function): any => f(x),\n    fold: (_: Function, f: Function): any => f(x),\n    fork: (f: Function, _: Function): any => f(x),\n    head: (): Array<T> | T => (Array.isArray(x) && x.length ? x[0] : []),\n    tail: (): Array<T> | T =>\n        Array.isArray(x) && x.length ? x[x.length - 1] : [],\n    join: (): Array<T> | T => x,\n    inspect: (): string => `Fail(${x})`,\n    concat: (o: PassFailMonad): PassFailMonad =>\n        o.fork((r: any): FailMonad => Fail((x as Array<T>).concat(r)), noop),\n    ap: (y: PassFailMonad): FailMonad =>\n        y[$$passSymbol] ? Fail(x) : y.concat(Fail(x)),\n    answer: (\n        i: InquiryValue,\n        n: string = '(anonymous)',\n        Ix: Function = Inquiry\n    ): InquiryMonad => {\n        i.informant([n, Fail(x)]);\n        return Ix({\n            subject: i.subject,\n            fail: i.fail.concat(Fail(x)),\n            pass: i.pass,\n            iou: i.iou,\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt.concat(Receipt([[n, Fail(x)]]))\n        });\n    },\n    isEmpty: (): Boolean => Boolean(!Array.isArray(x) || x.length === 0),\n    [$$passSymbol]: false,\n    [$$failSymbol]: true,\n    [$$iouSymbol]: false,\n    [$$inquirySymbol]: false\n});\n\nconst Receipt = (x: Array<ReceiptValue>): ReceiptMonad => ({\n    map: (f: Function): ReceiptMonad => Receipt(f(x)),\n    chain: (f: Function): any => f(x),\n    fold: (_: Function, f: Function): any => f(x),\n    fork: (f: Function, _: Function): any => f(x),\n    head: (): ReceiptValue => x[0],\n    tail: (): ReceiptValue => x[x.length - 1],\n    join: (): Array<ReceiptValue> => x,\n    inspect: (): string => `Receipt(${x})`,\n    isEmpty: (): Boolean => Boolean(!Array.isArray(x) || x.length === 0),\n    concat: (o: ReceiptMonad): ReceiptMonad =>\n        o.chain(\n            (r: any): ReceiptMonad =>\n                Receipt((x as Array<ReceiptValue>).concat(r))\n        ),\n    ap: (y: Monad): Monad => y.map(x),\n    [$$inquirySymbol]: false,\n    [$$receiptSymbol]: true\n});\n\nconst questionTypeError = (x: any): void =>\n    console.error(\n        'Question must be passed parameters that adhere to the documented type. Value that was passed:',\n        x\n    );\n\nconst Question = (x: QuestionValue): QuestionMonad => ({\n    map: (f: Function): QuestionMonad => Question(f(x)),\n    chain: (f: Function): any => f(x),\n    ap: (y: Monad): Monad => y.map(x),\n    inspect: (): string => `Question(${x})`,\n    join: (): any => x,\n    call: (i: InquiryMonad): PassFailMonad => x[1](i.join().subject.join()),\n    extract: (): Function => x[1],\n    name: (): string | RegExp => x[0],\n    [$$questionSymbol]: true\n});\n\nconst QuestionOf = (x: QuestionValue): QuestionMonad | void =>\n    Array.isArray(x) ? Question(x) : questionTypeError(x);\n\nconst exportQuestion: QuestionMonadConstructor = {\n    of: QuestionOf\n};\n\nconst Questionset = (x: Array<QuestionValue>): QuestionsetMonad => ({\n    map: (f: Function): QuestionsetMonad => Questionset(f(x)),\n    chain: (f: Function): any => f(x),\n    ap: (y: Monad): Monad => y.map(x),\n    inspect: (): string => `Questionset(${x})`,\n    join: (): any => x,\n    concat: (o: QuestionsetMonad): QuestionsetMonad =>\n        o.chain(\n            (r: any): QuestionsetMonad =>\n                Questionset((x as Array<QuestionValue>).concat(r))\n        ),\n    find: (a: string): Monad =>\n        Maybe.of(x.find(i => RegExp(i[0]).test(a)))\n            .map((b: QuestionValue): Function => b[1])\n            .fork((): symbol => {\n                console.warn('Question was not found: ', a);\n                return $$notFoundSymbol;\n            }, (c: Function): Function => c),\n    [$$questionsetSymbol]: true\n});\n\nconst questionsetTypeError = (x: any): void =>\n    console.error(\n        'Questionset must be passed parameters that adhere to the documented type. Value that was passed:',\n        x\n    );\n\nconst QuestionsetOf = (x: Array<QuestionValue>): QuestionsetMonad | void =>\n    Array.isArray(x) ? Questionset(x) : questionsetTypeError(x);\n\nconst exportQuestionset: QuestionsetMonadConstructor = {\n    of: QuestionsetOf\n};\n\nconst InquirySubject = (x: any | InquiryMonad): InquiryMonad =>\n    (x as any)[$$inquirySymbol]\n        ? x\n        : Inquiry({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset([['', noop]]),\n              receipt: Receipt([])\n          });\n\nconst warnTypeError = <T>(x: T): InquiryMonad => {\n    console.warn(\n        'Inquiry.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to Inquiry.subject().'\n    );\n    return InquirySubject(x);\n};\n\n// @todo validate constructor via Symbol\nconst InquiryOf = (x: InquiryValue): InquiryMonad =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n        ? Inquiry(x)\n        : warnTypeError(x);\n\nconst Inquiry = (x: InquiryValue): InquiryMonad => ({\n    // Inquire: core method\n    // You may pass a Function, a QuestionMonad (with a function), or a string which will look up\n    //  in the current Inquiry's questionset.\n    // @todo in 1.x, deprecate Function as an option\n    // @todo should we allow a Questionset to be passed here, and process all of them?\n    // @todo after simplifying, can BoolTable help here?\n    inquire: (f: Function | string | QuestionMonad): InquiryMonad => {\n        const extractName = (f: string | QuestionMonad) =>\n            (f as QuestionMonad)[$$questionSymbol]\n                ? (f as QuestionMonad).name()\n                : f;\n        const fnName =\n            typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n        const warnNotPassFail = (resp: any): InquiryMonad => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            console.warn('response was:', resp);\n            return Inquiry(x);\n        };\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        return inquireResponse[$$failSymbol] ||\n            inquireResponse[$$passSymbol] ||\n            inquireResponse[$$inquirySymbol]\n            ? inquireResponse.answer(x, fnName, Inquiry)\n            : warnNotPassFail([inquireResponse, fnName]);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const extractName = (f: string | QuestionMonad) =>\n                    (f as QuestionMonad)[$$questionSymbol]\n                        ? (f as QuestionMonad).name()\n                        : f;\n                const fnName =\n                    typeof f === 'function' ? f.name || 'anon' : extractName(f);\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn\n                    ? fExtractFn\n                    : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n                const warnNotPassFail = (resp: any): InquiryMonad => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    console.warn('response was:', resp);\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                // each return aggregates new contained value through exit\n                return inquireResponse[$$failSymbol] ||\n                    inquireResponse[$$passSymbol] ||\n                    inquireResponse[$$inquirySymbol]\n                    ? inquireResponse.answer(inq.join(), fnName, Inquiry)\n                    : warnNotPassFail([inquireResponse, fnName]);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            Inquiry({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset,\n                receipt: x.receipt\n            })\n        ),\n\n        // @todo handle if no Questionset / .using()\n    inquireAll: (): InquiryMonad =>\n        (x.questionset as QuestionsetMonad).chain(\n            (questions: Array<QuestionValue>): InquiryMonad =>\n                questions.reduce(\n                    (inq: InquiryMonad, q: QuestionValue): InquiryMonad =>\n                        inq.inquire(QuestionOf(q)),\n                    Inquiry(x)\n                )\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a,\n            receipt: x.receipt\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    inspect: (): string =>\n        `Inquiry(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap pass/fail\n    swap: (): InquiryMonad =>\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort)\n        Inquiry({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // standard Monad methods\n    map: (f: Function): InquiryMonad => InquirySubject(f(x)),\n    ap: (y: Monad): Monad => y.map(x),\n    chain: (f: Function): any => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function): InquiryMonad =>\n        x.fail.join().length ? Inquiry(f(x)) : Inquiry(x),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function): InquiryMonad =>\n        x.pass.join().length ? Inquiry(f(x)) : Inquiry(x),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function): InquiryMonad => {\n        i.informant([n, Inquiry(x)]);\n        return Inquiry({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n\n    // Unwrap methods\n\n    // unwraps, mapping for both branches, full value returned\n    conclude: (f: Function, g: Function): InquiryValue => ({\n        subject: x.subject,\n        iou: x.iou,\n        fail: f(x.fail),\n        pass: g(x.pass),\n        informant: x.informant,\n        questionset: x.questionset,\n        receipt: x.receipt\n    }),\n\n    // If there are no fails, handoff aggregated passes to supplied function; if any fails, return noop\n    cleared: (f: Function): any | void =>\n        x.fail.isEmpty() ? f(x.pass) : noop(),\n\n    // If there are fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: (f: Function): void | any =>\n        x.fail.isEmpty() ? noop() : f(x.fail),\n\n    // If there are passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: (f: Function): void | any =>\n        x.pass.isEmpty() ? noop() : f(x.pass),\n\n    // If there are no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: (f: Function): any | void =>\n        x.pass.isEmpty() ? f(x.fail) : noop(),\n\n    // unwrap left if any fails, right if not\n    fork: (f: Function, g: Function): any =>\n        x.fail.join().length ? f(x.fail) : g(x.pass),\n\n    // unwrap left if any passes, right if not\n    fold: (f: Function, g: Function): any =>\n        x.pass.join().length ? f(x.pass) : g(x.fail),\n\n    // return a merged pass/fail\n    zip: (f: Function): Array<any> => f(x.fail.join().concat(x.pass.join())), // return a concat of pass/fails\n\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiry: InquiryConstructor = {\n    subject: InquirySubject,\n    of: InquiryOf\n};\n\nconst InquiryPSubject = (x: any | InquiryMonad): InquiryMonad =>\n    (x as any)[$$inquirySymbol]\n        ? x\n        : InquiryP({\n              subject: Maybe.of(x),\n              fail: Fail([]),\n              pass: Pass([]),\n              iou: IOU([]),\n              informant: <T>(_: T) => _,\n              questionset: Questionset([['', noop]]),\n              receipt: Receipt([])\n          });\n\nconst warnTypeErrorP = <T>(x: T): InquiryMonad => {\n    console.warn(\n        'InquiryP.of requires properties: subject, fail, pass, iou, informant, questionset, receipt. Converting to InquiryP.subject().'\n    );\n    return InquiryPSubject(x);\n};\n\nconst InquiryPOf = (x: InquiryValue): InquiryMonad =>\n    'subject' in x &&\n    'fail' in x &&\n    'pass' in x &&\n    'iou' in x &&\n    'informant' in x &&\n    'questionset' in x &&\n    'receipt' in x\n        ? InquiryP(x)\n        : warnTypeErrorP(x);\n\nconst buildInq = <T>(x: T) => (vals: Array<any>): InquiryMonad =>\n    vals\n        ? vals.reduce(\n              (acc, cur) =>\n                  cur ? cur[1].answer(acc, cur[0], InquiryP).join() : acc,\n              x\n          )\n        : x;\n\n// this is a bit complex, so here it goes:\n// Take all our IOUs (Questions), extract and resolve their Promises\n// then take those results apply to a tuple with the question name/description\nconst resolveQs = (x: InquiryValue) =>\n    x.iou.join().length\n        ? x.iou.join().map(\n              (q: QuestionMonad): Promise<PassFailMonad> =>\n                  q\n                      .extract()()\n                      .catch((err: any) => err)\n                      .then(\n                          (result: PassFailMonad): Promise<Array<any>> =>\n                              Promise.resolve([q.name(), result])\n                      )\n          )\n        : [Promise.resolve()];\n\nconst InquiryP = (x: InquiryValue): InquiryMonad => ({\n    inquire: (f: Function | string | QuestionMonad) => {\n        const extractName = (f: string | QuestionMonad) =>\n            (f as QuestionMonad)[$$questionSymbol]\n                ? (f as QuestionMonad).name()\n                : f;\n        const fnName =\n            typeof f === 'function' ? f.name || 'anon' : extractName(f);\n        const fExtractFn = (f as any)[$$questionSymbol]\n            ? (f as QuestionMonad).extract()\n            : f;\n        const fIsFn = typeof fExtractFn === 'function';\n        const inquire = fIsFn\n            ? fExtractFn\n            : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n        const warnNotPassFail = (resp: any): InquiryMonad => {\n            console.warn(\n                'inquire was passed a function that does not return Pass or Fail:',\n                fnName\n            );\n            console.warn('response was:', resp);\n            return InquiryP(x);\n        };\n\n        const inquireResponse =\n            typeof inquire === 'function' ? inquire(x.subject.join()) : {};\n\n        const syncronousResult = (response: any): InquiryMonad =>\n            response[$$failSymbol] ||\n            response[$$passSymbol] ||\n            response[$$inquirySymbol]\n                ? response.answer(x, fnName, InquiryP)\n                : warnNotPassFail([inquireResponse, fnName]);\n\n        const inquireIOU = inquireResponse.then\n            ? QuestionOf([fnName as string, () => inquireResponse])\n            : false;\n\n        return inquireIOU\n            ? InquiryP({\n                  subject: x.subject,\n                  fail: x.fail,\n                  pass: x.pass,\n                  iou: x.iou.concat(IOU([inquireIOU])),\n                  informant: x.informant,\n                  questionset: x.questionset,\n                  receipt: x.receipt\n              })\n            : syncronousResult(inquireResponse);\n    },\n\n    inquireMap: (\n        f: Function | string | QuestionMonad,\n        i: Array<any>\n    ): InquiryMonad =>\n        i.reduce(\n            (inq, ii) => {\n                const extractName = (f: string | QuestionMonad) =>\n                    (f as QuestionMonad)[$$questionSymbol]\n                        ? (f as QuestionMonad).name()\n                        : f;\n                const fnName =\n                    typeof f === 'function' ? f.name || 'anon' : extractName(f);\n                const fExtractFn = (f as any)[$$questionSymbol]\n                    ? (f as QuestionMonad).extract()\n                    : f;\n                const fIsFn = typeof fExtractFn === 'function';\n                const inquire = fIsFn\n                    ? fExtractFn\n                    : (x.questionset as QuestionsetMonad).find(fExtractFn);\n\n                const warnNotPassFail = (resp: any) => {\n                    console.warn(\n                        'inquire was passed a function that does not return Pass or Fail:',\n                        fnName\n                    );\n                    console.warn('response was:', resp);\n                    return inq;\n                };\n                const inquireResponse =\n                    typeof inquire === 'function'\n                        ? inquire(ii)(inq.join().subject.join())\n                        : {};\n\n                const syncronousResult = (response: any): InquiryMonad =>\n                    response[$$failSymbol] ||\n                    response[$$passSymbol] ||\n                    response[$$inquirySymbol]\n                        ? response.answer(inq.join(), fnName, InquiryP)\n                        : warnNotPassFail(response);\n\n                return inquireResponse.then\n                    ? InquiryP({\n                          subject: inq.join().subject,\n                          fail: inq.join().fail,\n                          pass: inq.join().pass,\n                          iou: inq.join().iou.concat(IOU([inquireResponse])),\n                          informant: inq.join().informant,\n                          questionset: inq.join().questionset,\n                          receipt: inq.join().receipt\n                      })\n                    : syncronousResult(inquireResponse);\n            },\n\n            // initial Inquiry will be what is in `x` now\n            InquiryP({\n                subject: x.subject,\n                iou: x.iou,\n                fail: x.fail,\n                pass: x.pass,\n                informant: x.informant,\n                questionset: x.questionset,\n                receipt: x.receipt\n            })\n        ),\n\n    inquireAll: (): InquiryMonad =>\n        (x.questionset as QuestionsetMonad).chain(\n            (questions: Array<QuestionValue>): InquiryMonad =>\n                questions.reduce(\n                    (inq: InquiryMonad, q: QuestionValue): InquiryMonad =>\n                        inq.inquire(QuestionOf(q)),\n                    InquiryP(x)\n                )\n        ),\n\n    using: (a: QuestionsetMonad): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: x.informant,\n            questionset: a,\n            receipt: x.receipt\n        }),\n\n    // Informant: for spying/logging/observable\n    informant: (f: Function): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: x.fail,\n            pass: x.pass,\n            informant: f,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    inspect: (): string =>\n        `InquiryP(${x.fail.inspect()} ${x.pass.inspect()} ${x.iou.inspect()}`,\n\n    // Flow control: swap left/right pass/fail (iou is untouched)\n    swap: (): InquiryMonad =>\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(x.pass.join()),\n            pass: Pass(x.fail.join()),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Mapping across both branches\n    unison: (\n        f: Function\n    ): InquiryMonad => // apply a single map to both fail & pass (e.g. sort), iou untouched\n        InquiryP({\n            subject: x.subject,\n            iou: x.iou,\n            fail: Fail(f(x.fail.join())),\n            pass: Pass(f(x.pass.join())),\n            informant: x.informant,\n            questionset: x.questionset,\n            receipt: x.receipt\n        }),\n\n    // Standard monad methods - note that while these work, remember that `x` is a typed Object\n    map: (f: Function): InquiryMonad => InquiryPSubject(f(x)), // cast required for now\n    ap: (y: Monad): Monad => y.map(x),\n    chain: (f: Function): any => f(x),\n    join: (): InquiryValue => x,\n\n    // execute the provided function if there are failures, else continue\n    breakpoint: (f: Function): InquiryMonad =>\n        x.fail.join().length ? InquiryP(f(x)) : InquiryP(x),\n\n    // execute the provided function if there are passes, else continue\n    milestone: (f: Function): InquiryMonad =>\n        x.pass.join().length ? InquiryP(f(x)) : InquiryP(x),\n\n    // internal method: execute informant, return new InquiryP() based on updated results\n    answer: (i: InquiryValue, n: string, _: Function): InquiryMonad => {\n        i.informant([n, InquiryP(x)]);\n        return InquiryP({\n            subject: i.subject,\n            iou: i.iou,\n            fail: i.fail.concat(x.fail),\n            pass: i.pass.concat(x.pass),\n            informant: i.informant,\n            questionset: i.questionset,\n            receipt: i.receipt\n        });\n    },\n\n    // Unwrapping methods: all return Promises, all complete outstanding IOUs\n\n    // Unwraps the Inquiry after ensuring all IOUs are completed\n    conclude: async (f: Function, g: Function): Promise<InquiryValue> => {\n        return PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => ({\n                subject: y.subject,\n                iou: y.iou,\n                fail: f(y.fail),\n                pass: g(y.pass),\n                informant: y.informant,\n                questionset: y.questionset,\n                receipt: y.receipt\n            }));\n    },\n\n    // If no fails, handoff aggregated passes to supplied function; if fails, return noop\n    cleared: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? f(y.pass) : noop()))\n            .catch(err => console.error('err', err)),\n\n    // If fails, handoff aggregated fails to supplied function; if no fails, return noop\n    faulted: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.isEmpty() ? noop() : f(y.fail))),\n\n    // If any passes, handoff aggregated passes to supplied function; if no passes, return noop\n    suffice: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? noop() : f(y.pass)))\n            .catch(err => console.error('err', err)),\n\n    // If no passes, handoff aggregated fails to supplied function; if any passes, return noop\n    scratch: async (f: Function): Promise<InquiryMonad | Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.isEmpty() ? f(y.fail) : noop())),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fork: async (f: Function, g: Function): Promise<Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.fail.join().length ? f(y.fail) : g(y.pass))),\n\n    // Take left function and hands off fails if any, otherwise takes right function and hands off passes to that function\n    fold: async (f: Function, g: Function): Promise<Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => (y.pass.join().length ? f(y.pass) : g(y.fail))),\n\n    // return a Promise containing a merged fail/pass resultset array\n    zip: async (f: Function): Promise<Array<any>> =>\n        PromiseEvery(resolveQs(x))\n            .then(buildInq(x))\n            .then(i => (i[$$inquirySymbol] ? i.join() : i))\n            .then(y => f(y.fail.join().concat(y.pass.join()))),\n\n    // await all IOUs to resolve, then return a new Inquiry CONVERTS TO PROMISE!\n    await: async (t: number = Infinity): Promise<InquiryMonad> => {\n        // try: generator function. Each IOU = array in for loop as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield\n        const timeLimit = new Promise((resolve, reject) =>\n            setTimeout(resolve, t, [\n                'timeout',\n                Fail('Promise(s) have timed out')\n            ])\n        );\n        const awaitPromises = PromiseEvery(resolveQs(x));\n\n        return (\n            Promise.race([timeLimit, awaitPromises])\n                // @ts-ignore\n                .then(buildInq(x))\n                .then((i: any) => (i[$$inquirySymbol] ? i.join() : i))\n                .then((y: any) => InquiryPOf(y))\n        );\n    },\n    [$$inquirySymbol]: true\n});\n\nconst exportInquiryP: InquiryConstructor = {\n    subject: InquiryPSubject,\n    of: InquiryPOf\n};\n\nexport {\n    exportInquiry as Inquiry,\n    exportInquiryP as InquiryP,\n    exportQuestionset as Questionset,\n    exportQuestion as Question,\n    Receipt,\n    Fail,\n    Pass,\n    IOU,\n    $$inquirySymbol,\n    $$questionSymbol,\n    $$passSymbol,\n    $$failSymbol\n};\n"],"sourceRoot":""}